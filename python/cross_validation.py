"""
Created on Mon Sep 13 2021

@author: Michele Stofella

"""

from exPfact import run
from read import read_assignments, read_seq, read_dexp, read_pfact, read_configuration
from calc_dpred import calculate_dpred
from kint import calculate_kint_for_sequence
import numpy as np
import os
import argparse
import sys 

lambdas = np.logspace(-15,1,20)

def L1OUT_dataset(dexp, time_points, k):
    """
    This function splits the experimental dataset composed by N time points and M peptides
    into a training dataset composed by all N time points except the k-th index (1<=k<=N)
    and a test dataset composed by the remaining time point.
    """
    dexp_train  = np.array([np.delete(dexp[j],k) for j in range(len(dexp))])
    times_train = np.delete(time_points,k)
    dexp_test = np.array([dexp[j][k] for j in range(len(dexp))]) 
    times_test = np.array([time_points[k]])
    return dexp_train, times_train, dexp_test, times_test

def L1OUT_crossval(dexp, time_points, ass, lam, pH, temp, seq, res1, resn):
    """
    This function performs leave-one-out cross-validation at a fixed value of lambda. 
    All protecion factors are initialized to ln(P)=1 (except prolines, for which ln(P)=-1).
    A minimization is applied using a specific penalization term lambda. 
    The cross validation error is evaluated on every train and test datasets
    generated by leaving out one time point at a time. 
    """
    CVtrain = 0
    CVtest  = 0
    for k in range(len(time_points)):
        
        out_file = "CVout.rm"+str(k)

        dexp_train, times_train, dexp_test, times_test = L1OUT_dataset(dexp, time_points, k)
        
        run(base_dir=os.getcwd(), dexp=dexp_train, assignments=ass, pfact=None, 
            random_steps=None, time_points=times_train, harmonic_term=lam, 
            output_file=out_file, tolerance=None, weights=None, 
            pH=pH, temperature=temp, seq=seq, res1=res1, resn=resn)
        
        pfact = read_pfact(out_file+'.pfact')
        dpred_test = calculate_dpred(pfact,times_test,kint,ass)
        cost_test = [np.sqrt(1 / len(pred) * np.sum((pred - exp) ** 2)) for pred, exp in zip(dpred_test, dexp_test)]
        
        CVtrain += sum(np.loadtxt(out_file+'.diff'))[1]
        CVtest  += sum(cost_test)
        
        os.remove(out_file+".Dpred") 
        os.remove(out_file+".diff") 
        os.remove(out_file+".pfact") 
    return CVtrain, CVtest

def cross_validate(dexp, time_points, ass, lambdas, pH, temp, seq, res1, resn):
    """
    This function applies leave-one-out cross-validation to a dataset at varying values of the penalty term lambda. 
    The values for lambda are fixed (line 19) and cover 10 orders of magnitude. 
    For each value of lambda, the function L1OUT_crossval is applied.
    """
    fout = open('CV.res','w+')
    for i in range(len(lambdas)):
        print("**********************************************************\n")
        print("      EXPLORING LAMBDA LANDSCAPE: lambda = "+"{:e}".format(lambdas[i]))
        if i >= 1:
            print("      COMPUTATION IN PROGRESS: "+str(round(i/len(lambdas)*100,2))+" %\n")
        CVtrain, CVtest = L1OUT_crossval(dexp, time_points, ass, lambdas[i], pH, temp, seq, res1, resn)
        fout.write('{} {} {}\n'.format(lambdas[i], CVtrain, CVtest))    
        print("**********************************************************")
    fout.close()
    
if __name__ == '__main__':

    parser = argparse.ArgumentParser()

    parser.add_argument("--dexp")
    parser.add_argument("--ass")
    parser.add_argument("--temp")
    parser.add_argument("--pH")
    parser.add_argument("--seq")

    if sys.argv[1].endswith('.json'):
        config = read_configuration(sys.argv[1])
    else:
        config = {}
        opts = parser.parse_args()

        # Compulsory arguments
        if opts.dexp:
            dexp, time_points = read_dexp(opts.dexp)
        if opts.ass:
            ass  = read_assignments(opts.ass)
        if opts.temp:
            temp = float(opts.temp)
        if opts.pH:
            pH   = float(opts.pH)
        if opts.seq:
            seq  = read_seq(opts.seq)
            res1 = 1
            resn = len(read_seq(opts.seq))

    kint, prolines = calculate_kint_for_sequence(res1, resn, seq, temp, pH)
    cross_validate(dexp, time_points, ass, lambdas, pH, temp, seq, res1, resn)